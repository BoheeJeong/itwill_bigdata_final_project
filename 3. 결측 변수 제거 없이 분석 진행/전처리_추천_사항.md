# 연속형·결측 전처리 추천 (데이터 기반)

현재 파이프라인: 연속형 → **median 대체 + StandardScaler**, 명목형 → **'Missing' 대체 + OneHotEncoder**.  
아래는 효과를 기대할 수 있는 **추가 전처리** 제안입니다.

---

## 1. 로그 변환 (Log transform) — **추천**

**대상:** 금액·자산·소득 등 **비율척도이며 오른쪽 꼬리가 긴 연속형 변수**

- 이런 변수는 그대로 두면 극단값이 모델에 과한 영향을 주고, 선형/로지스틱 계수 해석이 어려워집니다.
- **`np.log1p(x)`** 적용 시:  
  - 0·결측 대체값도 안전 (log(0) 방지),  
  - 분포가 덜 치우치고, 계수는 “약간의 배수 변화”로 해석 가능.

**로그 변환 권장 컬럼 (연속형 중 금액·규모 변수):**

| 컬럼명 | 추정 내용 |
|--------|-----------|
| `w09earned` | 소득(근로 등) |
| `w09pinc` | 개인소득 |
| `w09e201`, `w09e207`, `w09e213`, `w09e219`, `w09e225`, `w09e231`, `w09e237`, `w09e243`, `w09e273`, `w09e251` | 소득/자산 관련 |
| `w09passets` | 개인 자산 |
| `w09pliabilities` | 개인 부채 |
| `w09pnetassets` | 개인 순자산 |
| `w09hhinc` | 가구소득 |
| `w09hhassets` | 가구 자산 |
| `w09hhliabilities` | 가구 부채 |
| `w09hhnetassets` | 가구 순자산 |
| `w09fromchildren`, `w09tochildren` | 자녀에게서/에게 이전 |
| `w09transferfrom`, `w09transferto` | 이전소득 등 |

**주의:**  
- **음수·결측 대체값**이 있으면 `log1p` 전에 해당 값을 0으로 두거나, “로그 적용 대상에서 제외”하는 편이 안전합니다.  
- 나이(`w09a002_age`), 출생년도(`w09year2`), BMI(`w09bmi`), 점수형(w09g026~w09g032 등)은 **로그 변환 비추천** (해석·분포 상).

**파이프라인 반영 예시 (연속형 중 일부만 로그):**

- 로그 쓸 컬럼 리스트 `log_cols`를 두고,  
  **imputer → (해당 컬럼만) FunctionTransformer(np.log1p) → StandardScaler**  
  순서로 넣거나,  
- `ColumnTransformer`에서  
  - `("num_log", Pipeline([("imputer", SimpleImputer(strategy="median")), ("log", FunctionTransformer(np.log1p)), ("scaler", StandardScaler())], log_cols)`  
  - `("num_other", Pipeline([("imputer", SimpleImputer(strategy="median")), ("scaler", StandardScaler())], num_cols 제외 log_cols)`  
  처럼 연속형을 “로그 쓸 변수 / 나머지”로 나누어 적용할 수 있습니다.

---

## 2. 연속형 결측 대체 (이미 적용됨 + 선택 옵션)

- **현재:** 연속형은 **median**으로 대체 → 이상치에 강하고, 금액·자산처럼 치우친 변수에도 무난합니다.
- **유지 권장:** 전반적으로 **median 유지**를 추천합니다.
- **선택 사항:**  
  - 분포가 대략 대칭인 변수(나이, 일부 점수)만 **mean** 대체를 시도해 볼 수 있으나,  
  - 컬럼별로 다르게 두면 파이프라인이 복잡해지므로, **일괄 median**이 실무에서는 단순하고 안전합니다.
- **고급:** 결측이 많은 변수는 **KNNImputer**나 **IterativeImputer**를 시험해 볼 수 있으나, 연산 비용·과적합 가능성을 고려해, 우선은 median으로 안정화한 뒤 성능 비교하는 것을 권합니다.

---

## 3. 이상치 처리 (Winsorization) — **선택**

- 금액·자산 변수는 **극단값**이 회귀/로지스틱 계수와 SHAP에 큰 영향을 줄 수 있습니다.
- **1·99 백분위수(또는 5·95)로 자르는 winsorization**을 로그 변환 **이전**에 적용하면, 극단값 영향이 줄어듭니다.
- 적용 시 **train 기준** 백분위수를 구하고, test는 그 값으로 자르도록 해야 데이터 누수가 없습니다.
- 트리 계열(XGB/LGBM/CatBoost/RF)은 스케일·이상치에 상대적으로 덜 민감하므로, **로지스틱·경사하강법·SVM·KNN**에서 우선 적용해 보는 것을 추천합니다.

---

## 4. 요약 적용 순서 제안

1. **공통:**  
   연속형 **median 대체 → (금액·자산 등만) log1p → StandardScaler**  
   (로그 적용하지 않는 연속형은 median → scaler만.)
2. **선택:**  
   로지스틱/SVM/KNN 등에서 **금액·자산 변수**에 대해 train 기준 **winsorization** 후 위 순서 적용.
3. **명목형:**  
   현재처럼 **'Missing' 대체 + OneHotEncoder(drop='first')** 유지.

이 순서로 파이프라인을 확장하면, 연속형 분포와 결측 처리 측면에서 효과를 기대할 수 있습니다.
